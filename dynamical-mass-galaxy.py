# -*- coding: utf-8 -*-
"""1_dynamical_mass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GPhgbkvqRC2VJ5itNoKdQbd0ckb7_g7g
"""

# Objective: To calculate the diameter and the mass of the cluster
# Tissya Malik (ISA Admission No. 528901)

"""### Step 1: Importing Necessary Libraries
We begin by importing Python libraries
- `matplotlib.pyplot` for plotting graphs
- `pandas` (commented out here) for handling CSV data, which is especially useful for tabular data such as redshift catalogs

> Tip: If you havenâ€™t used `pandas` before, itâ€™s worth learning

"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from astropy.constants import G, c
from astropy.cosmology import Planck18 as cosmo
import astropy.units as u

from google.colab import drive
drive.mount('drive')

df=pd.read_csv("/content/drive/MyDrive/ISA Workshop/Skyserver_SQL7_1_2025 5_59_42 AM.csv", skiprows=[0])
df.head(10)
# the column names are not being read correctly due to the first row being treated as part of the data rather than the header.
# The actual header seems to be in the second row, starting with "objid".
#  column names are not being read correctly because of the extra line at the beginning of the file
# We can fix this by telling pd.read_csv to skip the first row

"""
Before we begin calculations, we define key physical constants used throughout:

- $ H_0 $: Hubble constant, describes the expansion rate of the Universe.
- $c$ : Speed of light.
-  $G$: Gravitational constant.
- $q_0$ : Deceleration parameter, used for approximate co-moving distance calculations.

We will use **`astropy.constants`** to ensure unit consistency and precision."""

# Constants:

H_0 = 67.4 * u.km / u.s / u.Mpc # Hubble constant in SI # describes the expansion rate of the Universe.
c = c # Speed of light in m/s, using the value from astropy.constants
G = G # Gravitational constant in parsec kg^-1 (m/s)^2, using the value from astropy.constants
q0= -0.534  # Deceleration parameter (assumed from Planck fit KEEP it as it is)

"""### ðŸ“Š Calculating the Average Spectroscopic Redshift (`specz`) for Each Object

When working with astronomical catalogs, an object (identified by a unique `objid`) might have multiple entries â€” for example, due to repeated observations. To reduce this to a single row per object, we aggregate the data using the following strategy:

```python
averaged_df = df.groupby('objid').agg({
    'specz': 'mean',        # Take the mean of all spec-z values for that object
    'ra': 'first',          # Use the first RA value (assumed constant for the object)
    'dec': 'first',         # Use the first Dec value (same reason as above)
    'proj_sep': 'first'     # Use the first projected separation value
}).reset_index()

"""

averaged_df = df.groupby('objid').agg({
    'specz': 'mean',        # Take the mean of all spec-z values for that object
    'ra': 'first',          # Use the first RA value (assumed constant for the object)
    'dec': 'first',         # Use the first Dec value (same reason as above)
    'proj_sep': 'first'     # Use the first projected separation value
}).reset_index()

# Calculating the average specz for each id:
averaged_df = df.groupby('objid').agg({'specz': 'mean','ra': 'first','dec': 'first','proj_sep': 'first',}).reset_index()
averaged_df.describe()['specz']

"""To create a cut in the redshift so that a cluster can be identified. We must use some logic. Most astronomers prefer anything beyond 3*sigma away from the mean to be not part of the same group.

Find the mean, standard deviation and limits of the redshift from the data
"""

# Find the mean, standard deviation and limits of the redshift from the data
mean_specz = averaged_df['specz'].mean()
std_specz = averaged_df['specz'].std()

lower_limit = mean_specz - 3 * std_specz
upper_limit = mean_specz + 3 * std_specz

print(f"Mean spectroscopic redshift: {mean_specz:.4f}")
print(f"Standard deviation of spectroscopic redshift: {std_specz:.4f}")
print(f"Lower limit (mean - 3*sigma): {lower_limit:.4f}")
print(f"Upper limit (mean + 3*sigma): {upper_limit:.4f}")

"""You can also use boxplot to visualize the overall values of redshift"""

# Plot the dsitribution of redshift as boxplot
plt.figure(figsize=(8, 6))
plt.boxplot(averaged_df['specz'], vert=False, patch_artist=True)
plt.title("Boxplot of Redshift Distribution")
plt.xlabel("Spectroscopic Redshift (specz)")
plt.grid(True)
plt.show()

"""But the best plot would be a histogram to see where most of the objects downloaded lie in terms of redshift value"""

# Plot the dsitribution of redshift as histogram
plt.hist(averaged_df['specz'],bins=90)
plt.grid()
plt.show()

"""Filter your data based on the 3-sigma limit of redshift. You should remove all data points which are 3-sigma away from mean of redshift"""

# Filtering the data based on redshift (specz) values, used 3 sigma deviation from mean as upper limit.
filtered_df = averaged_df[(averaged_df['specz'] > lower_limit) & (averaged_df['specz'] < upper_limit)].copy()
print(f"Number of objects before filtering: {len(averaged_df)}")
print(f"Number of objects after filtering: {len(filtered_df)}")
filtered_df.head()

"""Use the relation between redshift and velocity to add a column named velocity in the data. This would tell the expansion velocity at that redshift"""

# Use the relation between redshift and velocity to add a column named velocity in the data.
# This would tell the expansion velocity at that redshift
filtered_df['velocity'] = filtered_df['specz'] * c.to(u.km/u.s)
filtered_df.head()

#plot the velocity column created as histogram
plt.figure(figsize=(8, 6))
plt.hist(filtered_df['velocity'], bins=20, edgecolor='black') # Adjust bins as needed
plt.title('Distribution of Galaxy Velocities')
plt.xlabel('Velocity (km/s)')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

"""use the dispersion equation to find velocity dispersion. You can even refer to wikipedia to know about the term [wiki link here](https://en.wikipedia.org/wiki/Velocity_dispersion#:~:text=In%20astronomy%2C%20the%20velocity%20dispersion,%2C%20galaxy%20cluster%2C%20or%20supercluster.)

It is the velocity dispersion value which tells us, some galaxies might be part of even larger groups!!

### Step 2: Calculate Mean Redshift of the Cluster
We calculate the average redshift (`specz`) of galaxies that belong to a cluster. This gives us an estimate of the cluster's systemic redshift.

`cluster_redshift = filtered_df['specz'].mean()`

The velocity dispersion \( v \) of galaxies relative to the cluster mean redshift is computed using the relativistic Doppler formula:

$$
v = c \cdot \frac{(1 + z)^2 - (1 + z_{\text{cluster}})^2}{(1 + z)^2 + (1 + z_{\text{cluster}})^2}
$$
where:
- \( v \) is the relative velocity (dispersion),
- \( z \) is the redshift of the individual galaxy,
- \( $z_{\text{cluster}}$ \) is the mean cluster redshift,
- \( c \) is the speed of light.
"""

cluster_redshift = filtered_df['specz'].mean()
print(f"The mean redshift of the cluster is: {cluster_redshift:.4f}")

"""Pro tip: Check what the describe function of pandas does. Does it help to get quick look stats for your column of dispersion??"""

# Use the describe function on the 'relative_velocity' column
print("Descriptive statistics for 'relative_velocity':")
print(filtered_df['relative_velocity'].describe())

print(f"The value of the cluster redshift = {cluster_redshift:.4}")
print(f"The characteristic value of velocity dispersion of the cluster along the line of sight = {disp:.4} km/s.")

"""### Step 4: Visualizing Angular Separation of Galaxies
We plot a histogram of the projected (angular) separation of galaxies from the cluster center. This helps us understand the spatial distribution of galaxies within the cluster field.

- The x-axis represents the angular separation (in arcminutes or degrees, depending on units).
- The y-axis shows the number of galaxies at each separation bin.


"""

#Plot histogram for projected seperation (proj_sep) column
plt.figure(figsize=(8, 6))
plt.hist(filtered_df['proj_sep'], bins=20, edgecolor='black') # Adjust bins as needed
plt.title('Distribution of Projected Separation')
plt.xlabel('Projected Separation')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

"""### Determining size and mass of the cluster:

### Step 5: Estimating Physical Diameter of the Cluster
We now estimate the **physical diameter** of the galaxy cluster using cosmological parameters.

- `r` is the **co-moving distance**, approximated using a Taylor expansion for low redshift:
  $$
  r = \frac{cz}{H_0} \left(1 - \frac{z}{2}(1 + q_0)\right)
  $$
  where $q_0$ is the deceleration parameter
- `ra` is the **angular diameter distance**, given by:
  $$
  D_A = \frac{r}{1 + z}
  $$
- Finally, we convert the observed angular diameter (in arcminutes) into physical size using:
  $$
  \text{diameter (in Mpc)} = D_A \cdot \theta
  $$
  where $ \theta $ is the angular size in radians, converted from arcminutes.

> This gives us a rough estimate of the cluster's size in megaparsecs (Mpc), assuming a flat Î›CDM cosmology.
"""

# Calculating co-moving distance (r) using the approximation for low redshift
# We will use the mean cluster redshift for this calculation
r = (c.to(u.km/u.s) * cluster_redshift / H_0) * (1 - (cluster_redshift/2) * (1 + q0))
r = r.to(u.Mpc) # Convert to Mpc

# Calculating angular diameter distance (D_A or ra)
ra = r / (1 + cluster_redshift)

# Estimating physical diameter using the mean projected separation and angular diameter distance
# The projected separation in the data is in arcminutes, so we need to convert it to radians
mean_proj_sep_arcmin = filtered_df['proj_sep'].mean()
mean_proj_sep_rad = mean_proj_sep_arcmin * (u.arcmin).to(u.rad)

# Diameter in Mpc
diameter = ra * mean_proj_sep_rad
diameter = diameter.to(u.Mpc) # Ensure units are Mpc

print(f"The estimated physical diameter of the cluster is: {diameter:.4f}")

"""### Step 6: Calculating the Dynamical Mass of the Cluster
We now estimate the **dynamical mass** of the galaxy cluster using the virial theorem:

$$
M_{\text{dyn}} = \frac{3 \sigma^2 R}{G}
$$

Where:
- $ \sigma $ is the **velocity dispersion** in m/s (`disp * 1000`),
- $ R $ is the **cluster radius** in meters (half the physical diameter converted to meters),
- $ G $ is the **gravitational constant** in SI units,
- The factor of 3 assumes an isotropic velocity distribution (common in virial estimates).

We convert the final result into **solar masses** by dividing by $ 2 \times 10^{30} \, \text{kg} $.

> This mass estimate assumes the cluster is in dynamical equilibrium and bound by gravity.

"""

### Calculating the dynamical mass in solar masses:
M_dyn =3*((disp*1000)**2)*(diameter*0.5*10**6*3*10**16)/(G*2*10**30)

print(f"Dynamical Mass of the cluster is {M_dyn:.2e} solar mass")

# Calculate the velocity dispersion of galaxies relative to the cluster mean redshift
filtered_df['relative_velocity'] = c.to(u.km/u.s) * ((1 + filtered_df['specz'])**2 - (1 + cluster_redshift)**2) / ((1 + filtered_df['specz'])**2 + (1 + cluster_redshift)**2)

# The velocity dispersion is the standard deviation of these relative velocities
disp = filtered_df['relative_velocity'].std()

print(f"The characteristic value of velocity dispersion of the cluster along the line of sight = {disp:.4f} km/s.")

# final results

Mean spectroscopic redshift: 0.0808
Standard deviation of spectroscopic redshift: 0.0086

The mean redshift of the cluster is: 0.0801

The value of the cluster redshift = 0.08007
The characteristic value of velocity dispersion of the cluster along the line of sight = 1.218e+03 km/s

The estimated physical diameter of the cluster is: 0.5722 Mpc

Dynamical Mass of the cluster is 2.86e+14 s2 Mpc kg / m3 solar mass

Characteristic value of velocity dispersion of the cluster along the line of sight = 1218.4929 km/s